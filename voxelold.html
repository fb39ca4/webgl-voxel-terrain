<html><head>
<title>WebGL Voxel Demo</title>
<meta http-equiv="content-type" content="text/html; charset=utf8">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="webgl-debug.js"></script>
<script type="text/javascript" src="inputhelper.js"></script>
<script type="text/javascript" src="voxel.js"></script>
<script type="text/javascript" src="opentype.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 color;
    void main(void) {
        gl_FragColor = vec4(0.0, 1.0, 0.0, 0.5) + 0.0 * color;
    }
</script>

<script id="default-vs" type="x-shader/x-vertex">
    attribute vec2 vertexPos;
    
    uniform mat4 transform;
    
    void main(void) {
        gl_Position = transform * vec4(vertexPos, 0.0, 1.0);

    }
</script>

<script id="anchor-vs" type="x-shader/x-vertex">
    attribute vec2 vertexPos;
    
    uniform mat4 transform;
    
    void main(void) {
        gl_Position = transform * vec4(vertexPos, 0.0, 1.0);

    }
</script>

<script id="anchor-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform vec4 color;

    void main(void) {
        gl_FragColor = color;//vec4(0.0, 0.0, 0.0, 1.0);
    }
</script>


<script id="bezier-vs" type="x-shader/x-vertex">
    attribute vec2 vertexPos;
    attribute vec2 bezierAttrib;
    
    uniform mat4 transform;
    
    varying vec2 bezierCoord;
    
    void main(void) {
        gl_Position = transform * vec4(vertexPos, 0.0, 1.0);
        bezierCoord = bezierAttrib;
    }
</script>
<script id="bezier-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec2 bezierCoord;
    //uniform vec4 color;
    
    void main(void) {
        vec2 b = bezierCoord;
        if (b.s * b.s - b.t > 0.0) discard;
        gl_FragColor = vec4(1.0, b.s, b.t, 1.0);
    }
</script>

<script id="3d-vs" type="x-shader/x-vertex">
    attribute vec4 aPos;
    attribute vec4 aColor;
    
    uniform mat4 uTransform;
    
    varying vec4 vColor;
    
    void main(void) {
        gl_Position = uTransform * aPos;
        vColor = aColor;
    }
</script>

<script id="3d-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec4 vColor;
    
    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script type="text/javascript">

    var gl;
    var transform = mat4.create();
    
    mat4.perspective(transform, 0.8, 1.0, 0.1, 100.0);
    mat4.translate(transform, transform, vec4.fromValues(0.0, 0.0, -2.5, 0.0));
    mat4.rotateX(transform, transform, 0.5);
    mat4.translate(transform, transform, vec4.fromValues(-0.5, -0.5, 0.0, 0.0));
    mat4.scale(transform, transform, vec3.fromValues(1/1000.0, 1/1000.0, 1.0));
    
    
    fontVertices = [];
    
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl", {antialias:false, stencil:true});
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }
    
    function getProgram(gl, vertexShader, fragmentShader) {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
            console.log(gl.getProgramInfoLog(program));
            return null;
        }
        program.vertexAttribs = {};
        program.uniforms = {};
        return program;
    }
    
    function enableVAA(gl, program) {
        for (i in program.vertexAttribs) gl.enableVertexAttribArray(program.vertexAttribs[i]);
    }
    function disableVAA(gl, vertexAttribs) {
        for (i in program.vertexAttribs) gl.disableVertexAttribArray(program.vertexAttribs[i]);
    }

    function initShaders() {        
        anchorProgram = getProgram(gl, getShader(gl, "anchor-vs"), getShader(gl, "anchor-fs"));
        gl.useProgram(anchorProgram);
        anchorProgram.vertexAttribs.vertexPos = gl.getAttribLocation(anchorProgram, "vertexPos");
        anchorProgram.uniforms.transform = gl.getUniformLocation(anchorProgram, "transform");
        anchorProgram.uniforms.color = gl.getUniformLocation(anchorProgram, "color");
        
        bezierProgram = getProgram(gl, getShader(gl, "bezier-vs"), getShader(gl, "bezier-fs"));
        gl.useProgram(bezierProgram);
        bezierProgram.vertexAttribs.vertexPos = gl.getAttribLocation(bezierProgram, "vertexPos");
        bezierProgram.vertexAttribs.bezierAttrib = gl.getAttribLocation(bezierProgram, "bezierAttrib");
        bezierProgram.uniforms.transform = gl.getUniformLocation(bezierProgram, "transform");
        
        shaderProgram = getProgram(gl, getShader(gl, "3d-vs"), getShader(gl, "3d-fs"));
        gl.useProgram(shaderProgram);
        shaderProgram.vertexAttribs.pos = gl.getAttribLocation(shaderProgram, "aPos");
        shaderProgram.vertexAttribs.color = gl.getAttribLocation(shaderProgram, "aColor");
        shaderProgram.uniforms.transform = gl.getUniformLocation(shaderProgram, "uTransform");
        
        //gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        
    }


    var triangleVertexPositionBuffer;
    var squareVertexPositionBuffer;

    function loadBuffer(gl, vertices, itemSize) {
        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        buffer.itemSize = itemSize;
        buffer.numItems = Math.floor(vertices.length / buffer.itemSize);
        return buffer;
    }
    var anchorVertices = [];
    var bezierVertices = [];
    var anchorVertexBuffer;
    var bezierVertexBuffer;
    var blobVertexBuffer;
    var triangleVertexBuffer;
    function initBuffers() {
        var vertices = [
             -1.0,  1.0,
            -1.0, -1.0,
             1.0, -1.0,
             1.0, 1.0
        ];
        triangleVertexBuffer = loadBuffer(gl, vertices, 2);
        anchorVertexBuffer = loadBuffer(gl, anchorVertices, 2);
        bezierVertexBuffer = loadBuffer(gl, bezierVertices, 4);

	var quad = function(p, e1, e2, c) {
            var p1 = p.concat([1],c);
            var p2 = [p[0]+e1[0], p[1]+e1[1], p[2]+e1[2], 1].concat(c);
	    var p3 = [p2[0]+e2[0], p2[1]+e2[1], p2[2]+e2[2], 1].concat(c);
	    var p4 = [p[0]+e2[0], p[1]+e2[1], p[2]+e2[2], 1].concat(c);
            
	    return [].concat(p1, p2, p3, p1, p3, p4);
	}

       var tri = function(p, e1, e2, c) {
            c = [0.5, 0.5, 0.5, 0.5];
            var p1 = p.concat([1],c);
            var p2 = [p[0]+e1[0], p[1]+e1[1], p[2]+e1[2], 1].concat(c);
	    var p3 = [p[0]+e2[0], p[1]+e2[1], p[2]+e2[2], 1].concat(c);
	    console.log([].concat(p1, p2, p3));
	    return [].concat(p1, p2, p3);
	}
        
        var cubeVertices = [
            -1.0, -1.0, +1.0, 1.0, 0.5, 0.5, 1.0, 1.0,
            +1.0, -1.0, +1.0, 1.0, 0.5, 0.5, 1.0, 1.0,
            +1.0, +1.0, +1.0, 1.0, 0.5, 0.5, 1.0, 1.0,
            
            -1.0, -1.0, +1.0, 1.0, 0.5, 0.5, 1.0, 1.0,
            +1.0, +1.0, +1.0, 1.0, 0.5, 0.5, 1.0, 1.0,
            -1.0, +1.0, +1.0, 1.0, 0.5, 0.5, 1.0, 1.0,
            
            -1.0, -1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            +1.0, -1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            +1.0, +1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            
            -1.0, -1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            +1.0, +1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            -1.0, +1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            
            +1.0, -1.0, -1.0, 1.0, 1.0, 0.5, 0.5, 1.0,
            +1.0, +1.0, -1.0, 1.0, 1.0, 0.5, 0.5, 1.0,
            +1.0, +1.0, +1.0, 1.0, 1.0, 0.5, 0.5, 1.0,
            
            +1.0, -1.0, -1.0, 1.0, 1.0, 0.5, 0.5, 1.0,
            +1.0, +1.0, +1.0, 1.0, 1.0, 0.5, 0.5, 1.0,
            +1.0, -1.0, +1.0, 1.0, 1.0, 0.5, 0.5, 1.0,
            
            -1.0, -1.0, -1.0, 1.0, 1.0, 0.0, 0.0, 1.0,
            -1.0, +1.0, -1.0, 1.0, 1.0, 0.0, 0.0, 1.0,
            -1.0, +1.0, +1.0, 1.0, 1.0, 0.0, 0.0, 1.0,
            
            -1.0, -1.0, -1.0, 1.0, 1.0, 0.0, 0.0, 1.0,
            -1.0, +1.0, +1.0, 1.0, 1.0, 0.0, 0.0, 1.0,
            -1.0, -1.0, +1.0, 1.0, 1.0, 0.0, 0.0, 1.0,
            
            -1.0, +1.0, -1.0, 1.0, 0.5, 1.0, 0.5, 1.0,
            +1.0, +1.0, -1.0, 1.0, 0.5, 1.0, 0.5, 1.0,
            +1.0, +1.0, +1.0, 1.0, 0.5, 1.0, 0.5, 1.0,
            
            -1.0, +1.0, -1.0, 1.0, 0.5, 1.0, 0.5, 1.0,
            +1.0, +1.0, +1.0, 1.0, 0.5, 1.0, 0.5, 1.0,
            -1.0, +1.0, +1.0, 1.0, 0.5, 1.0, 0.5, 1.0,
            
            -1.0, -1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0,
            +1.0, -1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0,
            +1.0, -1.0, +1.0, 1.0, 0.0, 1.0, 0.0, 1.0,
            
            -1.0, -1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0,
            +1.0, -1.0, +1.0, 1.0, 0.0, 1.0, 0.0, 1.0,
            -1.0, -1.0, +1.0, 1.0, 0.0, 1.0, 0.0, 1.0
        ].concat(quad([-2,-1,-2],[4,0,0],[0,0,4],[0,0,0,1]));
        cubeVertices = [];
        cubeVertices = cubeVertices.concat(quad([-1,-1,1],[2,0,0],[0,2,0],[.5,.5,1,1]));
        cubeVertices = cubeVertices.concat(quad([-1,-1,-1],[0,2,0],[2,0,0],[0,0,1,1]));
        cubeVertices = cubeVertices.concat(quad([-1,1,-1],[0,0,2],[2,0,0],[.5,1,.5,1]));
        cubeVertices = cubeVertices.concat(quad([-1,-1,-1],[2,0,0],[0,0,2],[0,1,0,1]));
        cubeVertices = cubeVertices.concat(quad([1,-1,-1],[0,2,0],[0,0,2],[1,.5,.5,1]));
        cubeVertices = cubeVertices.concat(quad([-1,-1,-1],[0,0,2],[0,2,0],[1,0,0,1]));
        cubeVertices = cubeVertices.concat(quad([-2,-2,-1],[4,0,0],[0,4,0],[0,0,0,1]));
        cubeVertexBuffer = loadBuffer(gl, cubeVertices, 8);
    }


    function drawScene() {
        requestAnimationFrame(drawScene);
        var matrix = mat4.create();
        mat4.perspective(matrix, 0.8, canvas.clientWidth / canvas.clientHeight, 0.1, 100.0);
        mat4.translate(matrix, matrix, vec4.fromValues(0.0, 0.0, -5.0, 0.0));
        
        mat4.rotateX(matrix, matrix, (Date.now() / 1000.0) % (2 * Math.PI));
        //mat4.rotateX(matrix, matrix, (Date.now() / 1000.0) % (2 * Math.PI));
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        
        
        var perspectiveMatrix = mat4.perspective(mat4.create(), 0.8, canvas.clientWidth / canvas.clientHeight, 0.1, 100.0);
        
        //mat4.rotateY(perspectiveMatrix, perspectiveMatrix, Math.PI);     
        
        var cameraMatrix = mat4.create();
        mat4.lookAt(cameraMatrix, [-5*Math.cos(Date.now() / 1000.0),-5*Math.sin(Date.now() / 1000.0),1.5*Math.sin(Date.now()/326)], [0,0,0], [0,0,1]);
        
        //mat4.invert(cameraMatrix, cameraMatrix);
        
        var modelMatrix = mat4.create();
        //mat4.scale(modelMatrix, modelMatrix, [0.5, 0.5, 0.5]);
        //mat4.rotateY(modelMatrix, modelMatrix, (Date.now() / 1000.0) % (2 * Math.PI));
        mat4.translate(modelMatrix, modelMatrix, [0.0, 0.0, 0.0]);
        
        mat4.multiply(matrix, perspectiveMatrix, cameraMatrix);
        mat4.multiply(matrix, matrix, modelMatrix);

        gl.enable(gl.CULL_FACE);
        
        var buffer = cubeVertexBuffer;
        program = shaderProgram;
        gl.useProgram(program);
        gl.uniformMatrix4fv(program.uniforms.transform, false, matrix);
        enableVAA(gl, program);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(program.vertexAttribs.pos, 4, gl.FLOAT, false, 8 * 4, 0);
        gl.vertexAttribPointer(program.vertexAttribs.color, 4, gl.FLOAT, false, 8 * 4, 4 * 4);
        gl.drawArrays(gl.TRIANGLES, 0, buffer.numItems);
        disableVAA(gl, program);

    }

    function webGLStart() {
        displayGlyph = function(err, font){
            var commands
            if (err) {
                console.log(err);
                commands = [{"type":"M","x":917,"y":102},{"type":"Q","x1":957,"y1":64,"x":980,"y":16},{"type":"Q","x1":1003,"y1":-32,"x":1003,"y":-103},{"type":"Q","x1":1003,"y1":-174,"x":972,"y":-236.5},{"type":"Q","x1":941,"y1":-299,"x":878,"y":-345},{"type":"Q","x1":811,"y1":-392,"x":718,"y":-418},{"type":"Q","x1":625,"y1":-444,"x":488,"y":-444},{"type":"Q","x1":264,"y1":-444,"x":153,"y":-378.5},{"type":"Q","x1":42,"y1":-313,"x":42,"y":-187},{"type":"Q","x1":42,"y1":-85,"x":122,"y":-26},{"type":"Q","x1":202,"y1":33,"x":326,"y":38},{"type":"L","x":326,"y":52},{"type":"Q","x1":296,"y1":61,"x":264,"y":74.5},{"type":"Q","x1":232,"y1":88,"x":209,"y":106},{"type":"Q","x1":183,"y1":127,"x":167,"y":155.5},{"type":"Q","x1":151,"y1":184,"x":151,"y":226},{"type":"Q","x1":151,"y1":279,"x":188.5,"y":323.5},{"type":"Q","x1":226,"y1":368,"x":302,"y":400},{"type":"L","x":302,"y":415},{"type":"Q","x1":206,"y1":460,"x":153,"y":530.5},{"type":"Q","x1":100,"y1":601,"x":100,"y":694},{"type":"Q","x1":100,"y1":834,"x":204.5,"y":924},{"type":"Q","x1":309,"y1":1014,"x":472,"y":1014},{"type":"Q","x1":517,"y1":1014,"x":561.5,"y":1005},{"type":"Q","x1":606,"y1":996,"x":652,"y":982},{"type":"L","x":996,"y":982},{"type":"L","x":996,"y":886},{"type":"L","x":764,"y":886},{"type":"L","x":764,"y":880},{"type":"Q","x1":801,"y1":837,"x":819,"y":785},{"type":"Q","x1":837,"y1":733,"x":837,"y":683},{"type":"Q","x1":837,"y1":553,"x":731.5,"y":463},{"type":"Q","x1":626,"y1":373,"x":486,"y":373},{"type":"L","x":365,"y":373},{"type":"Q","x1":342,"y1":365,"x":317,"y":344},{"type":"Q","x1":292,"y1":323,"x":292,"y":287},{"type":"Q","x1":292,"y1":250,"x":313,"y":230.5},{"type":"Q","x1":334,"y1":211,"x":364,"y":204},{"type":"Q","x1":393,"y1":196,"x":431.5,"y":194},{"type":"Q","x1":470,"y1":192,"x":511,"y":191},{"type":"Q","x1":555,"y1":190,"x":631.5,"y":185},{"type":"Q","x1":708,"y1":180,"x":740,"y":179},{"type":"Q","x1":786,"y1":177,"x":832.5,"y":157},{"type":"Q","x1":879,"y1":137,"x":917,"y":102},{"type":"M","x":647,"y":687},{"type":"Q","x1":647,"y1":804,"x":599.5,"y":873.5},{"type":"Q","x1":552,"y1":943,"x":466,"y":943},{"type":"Q","x1":419,"y1":943,"x":385.5,"y":923.5},{"type":"Q","x1":352,"y1":904,"x":331,"y":868},{"type":"Q","x1":311,"y1":835,"x":302.5,"y":788.5},{"type":"Q","x1":294,"y1":742,"x":294,"y":693},{"type":"Q","x1":294,"y1":582,"x":342.5,"y":512},{"type":"Q","x1":391,"y1":442,"x":468,"y":442},{"type":"Q","x1":554,"y1":442,"x":600.5,"y":511.5},{"type":"Q","x1":647,"y1":581,"x":647,"y":687},{"type":"M","x":839,"y":-140},{"type":"Q","x1":839,"y1":-84,"x":813,"y":-48},{"type":"Q","x1":787,"y1":-12,"x":734,"y":1},{"type":"Q","x1":706,"y1":5,"x":619,"y":10},{"type":"Q","x1":532,"y1":15,"x":417,"y":15},{"type":"Q","x1":309,"y1":-6,"x":263.5,"y":-55.5},{"type":"Q","x1":218,"y1":-105,"x":218,"y":-183},{"type":"Q","x1":218,"y1":-218,"x":233,"y":-250},{"type":"Q","x1":248,"y1":-282,"x":285,"y":-309},{"type":"Q","x1":320,"y1":-335,"x":379,"y":-351.5},{"type":"Q","x1":438,"y1":-368,"x":523,"y":-368},{"type":"Q","x1":670,"y1":-368,"x":754.5,"y":-311.5},{"type":"Q","x1":839,"y1":-255,"x":839,"y":-140},{"type":"Z"}];
            }
            else {
                roboto = font;
                commands = roboto.glyphs[74].path.commands;
            }
            var a = anchorVertices;
            var b = bezierVertices;
            for (var i = 0; i < commands.length; i++) {
                var c = commands[i];
                var p = commands[i > 0 ? i - 1 : i];
                /*switch (c.type) {
                    case "M":
                        a.push(0, 0);
                        a.push(c.x, c.y);
                        break;
                    case "Q":
                        a.push(c.x, c.y);
                        b.push(p.x, p.y);
                        b.push(0, 0);
                        b.push(c.x1, c.y1);
                        b.push(0.5, 0);
                        b.push(c.x, c.y);
                        b.push(1, 1);
                        break;
                    case "Z":
                        a.push(0, 0);
                    default:
                        a.push(c.x, c.y);
                }*/
                switch (c.type) {
                    case "M":
                        break;
                    case "L":
                        b.push(0, 0, 0, 1);
                        b.push(p.x, p.y, 0, 1);
                        b.push(c.x, c.y, 0, 1);
                        break;
                    case "Q":
                        b.push(0, 0, 0, 1);
                        b.push(p.x, p.y, 0, 1);
                        b.push(c.x, c.y, 0, 1);
                        b.push(p.x, p.y, 0, 0);
                        b.push(c.x1, c.y1, 0.5, 0);
                        b.push(c.x, c.y, 1, 1);
                        break;
                    case "Z":
                        //b.push(0, 0, 0, 1);
                        //b.push(p.x, p.y, 0, 1);
                        //b.push(commands[0].x, commands[0].y, 0, 1);
                        break;
                    default:
                        b.push(0, 0, 0, 1);
                        b.push(p.x, p.y, 0, 1);
                        b.push(c.x, c.y, 0, 1);
                }
            }
            
            var canvas = document.getElementById("canvas");
            initGL(canvas);
            
            initShaders();
            initBuffers();

            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.enable(gl.DEPTH_TEST);

            drawScene();
        };
        displayGlyph("error", null);
        //opentype.load("roboto-black.ttf", displayGlyph);
        
        
        
    }


</script>


</head>


<body onload="webGLStart();">
    <canvas id="canvas" style="border: none;" width="854" height="480"></canvas>
    <br>
    <div id="keyboardDisplay"></div>
</body></html>